# Контейнер для мэппинга уникального целого числа на строку

## Вопрос:
Если нам потребуется мэппинг уникального целого числа на строку, то какой контейнер вы предложите?

## Ответ:
Обозначим тип *целого числа* `integral_type`, т.к. конкретного определения типа вопрос не предоставляет.

Также предположим, что под *строкой* подразумевается `std::string`, а не, например `std::wstring`.

### Базовый случай
В базовом варианте, когда ничего не известно об особенностях значений ключей, иммутабельности контейнера, и нет требований к упорядоченности ключей, а также если мы ограничимся лишь STL
стандартный выбор — `std::unordered_map<integral_type, std::string>`:
- поиск — средний *O(1)*, худший *O(N)* количестве при хэш-функции в стиле `return 42` для любого значения ключа.
- вставка и удаление — в среднем амортизированный *O(1)* (амортизация *O(N)* в силу возможного рехеширования и/или реаллокации бакетов hashmap), худший *O(N)*
Улучшить производительность можно при помощи custom allocator, дабы размещать chain-списки для бакетов в непрерывном участке памяти.

Более быстрыми во многих случаях будут flat hash maps с размещением нодов в непрерывной области памяти и использованием для разрешения коллизий open addressing вместо chaining, который используется в `unordered_map`. Непрерывное размещение в памяти обеспечивает меньшее количество CPU cache misses и лучшую производительность, open addressing позволяет сократить накладные расходы на указатели связанного списка при увеличении расходов на поиск свободной ячейки.
Пример реализации — `boost::unordered_flat_map` и похожие контейнеры в других сторонних библиотеках.

### Требование упорядоченности ключей
В случае необходимости поддерживать ключи в состоянии упорядоченности — `std::map<integral_type, std::string>`
- поиск, вставка и удаление — средний *O(logN)*, худший также *O(logN)* из-за почти полной сбалансированности красно-черного дерева, являющегося де-факто стандартной реализацией.
Аналогично `std::unordered_map` есть flat-версия в boost (`boost::flat_map`) и других сторонних библиотеках.

### Специальный случай значений ключей
Если нам известно, что наши ключи находятся в определенном диапазоне значений `[l, u]`, и заполненность диапазона
будет "достаточно" (что определяется задачей и местами личными предпочтениями инженера) значительной,
то можно использовать подход с `std::vector<std::string>` или `std::array<std::string, u - l + 1>`
Нахождение элемента по ключу в данном случае будет `vec[key - l]`. Для пустых ячеек можно использовать какой-либо magic number вне `[l, u]`.

В этом случае операции вставки, удаления и поиска всегда будут *O(1)* для `std::array` и `std::vector`, заранее созданного с размером `u - l + 1`.

В случае `std::vector` альтернативным подходом может быть хранение текущего максимального значения ключа и изменение размеров `std::vector` по необходимости. В данном случае операция вставки станет линейно-амортизированной. Можно сделать то же самое, используя текущее минимальное значение ключа и "реверсивную" адресацию `u - key`.

Это как и в случае с другими flat-контейнерами данный подход — CPU-cache-friendly.

### Специальный случай упорядоченной по ключу immutable-структуры
Продолжая наши буйные фантазии, мы можем представить специфический случай,
когда наш ассоциативный контейнер:
- не изменяется или изменяется крайне редко
- нам нужны упорядоченные ключи
- значения ключей имеют достаточно большой диапазон и нам нужен эффективный расход памяти.

В данном случае мы можем использовать сортированный по ключу `std::vector<std::pair<integral_type, std::string>>`.
Поиск (бинарный) — *O(logN)*, вставка и удаление — *O(N)*.
подход опять-таки CPU-cache-friendly.
