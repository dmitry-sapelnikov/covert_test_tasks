## Вопрос:
Если нам потребуется мэппинг уникального целого числа на строку, то какой контейнер вы предложите?

## Ответ:
Обозначим тип *целого числа* `integral_type`, т.к. конкретного определения типа вопрос не предоставляет.

Также предположим, что под *строкой* подразумевается `std::string`, а не, например `std::wstring`.

### Базовый случай
В базовом варианте, когда ничего не известно об особенностях значений ключей, иммутабельности контейнера, и нет требований к упорядоченности ключей, а также если мы ограничимся лишь STL, то стандартный выбор

`std::unordered_map<integral_type, std::string>`
- поиск — средний *O(1)*, худший *O(N)* при 100% коллизий.
- вставка и удаление — в среднем амортизированный *O(1)* (амортизация *O(N)* в силу возможного рехеширования и/или реаллокации бакетов hashmap), худший *O(N)*.

Улучшить производительность можно при помощи custom allocator, дабы размещать chain-списки для бакетов в непрерывном участке памяти.

Более быстрыми во многих случаях будут flat hash maps с размещением нодов в непрерывной области памяти и использованием для разрешения коллизий open addressing вместо chaining, который используется в `unordered_map`. Непрерывное размещение в памяти обеспечивает меньшее количество CPU cache misses и лучшую производительность, open addressing позволяет сократить накладные расходы на указатели связанного списка при увеличении расходов на поиск свободной ячейки.
Пример реализации — `boost::unordered_flat_map` и похожие контейнеры в других сторонних библиотеках.

### Требование упорядоченности ключей
В случае необходимости поддерживать ключи в состоянии упорядоченности контейнер выбора - 

`std::map<integral_type, std::string>`

Поиск, вставка и удаление — средний *O(logN)*, худший также *O(logN)* из-за почти полной сбалансированности красно-черного дерева, являющегося де-факто стандартной реализацией.
Аналогично `std::unordered_map` есть flat-версия в boost (`boost::flat_map`) и других сторонних библиотеках.

### Специальный случай значений ключей
Если нам известно, что наши ключи находятся в определенном диапазоне значений `[l, u]`, и заполненность диапазона
будет "достаточно значительной" (что определяется задачей и местами личными предпочтениями инженера),
то можно использовать 

`std::vector<std::string>` или `std::array<std::string, u - l + 1>`

Нахождение элемента по ключу в данном случае будет `vec[key - l]`. Для пустых ячеек можно использовать какой-либо magic number 
вне `[l, u]`.

В этом случае операции вставки, удаления и поиска всегда будут *O(1)* для `std::array` и `std::vector`, заранее созданного с размером `u - l + 1`.

В случае `std::vector` альтернативным подходом может быть хранение текущего максимального значения ключа и изменение размеров `std::vector` по необходимости. В данном случае операция вставки станет линейно-амортизированной. Можно сделать то же самое, используя текущее минимальное значение ключа и "реверсивную" адресацию `u - key`.

Это как и в случае с другими flat-контейнерами данный подход — CPU-cache-friendly.

### Потокобезопасный доступ
Для read-only контейнера дополнительные усилия для потокобезопасности не требуются.
Для изменяемых контейнеров с обеспечением потокобезопасности можно рассмотреть
`tbb::concurrent_hash_map`
`tbb::concurrent_map`
`tbb::concurrent_vector`
К ним применимы все вышеописанные рассуждения.
